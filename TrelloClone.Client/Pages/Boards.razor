@page "/boards"
@using TrelloClone.Shared.DTOs
@using TrelloClone.Client.Services
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@inject IBoardService BoardService
@inject IAuthService AuthService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@attribute [Authorize]

<PageTitle>Boards</PageTitle>

<AuthorizeView>
    <Authorized Context="authContext">
        <div class="boards-page">
            <div class="page-header">
                <div class="header-content">
                    <div class="header-text">
                        <h1>My Boards</h1>
                        @if (currentUser != null)
                        {
                            <p class="welcome-text">Welcome back, <strong>@currentUser.UserName</strong>!</p>
                        }
                    </div>
                    <button class="create-btn" @onclick="ShowCreateModal">
                        <i class="bi bi-plus-lg"></i> Create Board
                    </button>
                </div>
            </div>

            @if (isLoading)
            {
                <div class="loading-container">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p>Loading your boards...</p>
                </div>
            }
            else if (boards.Any())
            {
                <div class="boards-grid">
                    @{
                        var sortedBoards = boards.OrderBy(b => b.Position).ToList();
                    }
                    @for (int i = 0; i < sortedBoards.Count; i++)
                    {
                        var board = sortedBoards[i];
                        var index = i;
                        var isOwner = boardOwnership.GetValueOrDefault(board.Id, false);

                        <div class="board-drop-zone @(dragOverIndex == index ? "drag-over" : "")"
                             @ondragover="@((e) => HandleDragOver(e, index))"
                             @ondragover:preventDefault="true"
                             @ondrop="@((e) => HandleBoardDrop(e, index))"
                             @ondragleave="HandleDragLeave">

                            <div class="board-item @(draggedBoard?.Id == board.Id ? "dragging" : "")"
                                 draggable="true"
                                 @ondragstart="@((e) => HandleBoardDragStart(e, board))"
                                 @ondragend="HandleBoardDragEnd">
                                <BoardCard Board="board"
                                           CanEdit="@(boardPermissions.ContainsKey(board.Id) && boardPermissions[board.Id])"
                                           IsOwner="@isOwner"
                                           OnUpdate="ShowUpdateModal"
                                           OnDelete="DeleteBoard"
                                           OnLeave="LeaveBoard" />
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="empty-state">
                    <div class="empty-content">
                        <i class="bi bi-kanban"></i>
                        <h3>No boards found</h3>
                        <p>Create your first board to get started!</p>
                        <button class="btn-primary" @onclick="ShowCreateModal">
                            <i class="bi bi-plus-lg"></i> Create Board
                        </button>
                    </div>
                </div>
            }
        </div>

        <BoardModals ShowCreateModal="@showCreateModal"
                     ShowUpdateModal="@showUpdateModal"
                     NewBoard="@newBoard"
                     UpdateRequest="@updateRequest"
                     OnCreateBoard="@CreateBoard"
                     OnUpdateBoard="@UpdateBoard"
                     OnHideCreate="HideCreateModal"
                     OnHideUpdate="HideUpdateModal"
                     IsCreating="@isCreating"
                     IsUpdating="@isUpdating" />
    </Authorized>
    <NotAuthorized>
        <div class="access-denied">
            <div class="denied-content">
                <i class="bi bi-shield-lock"></i>
                <h3>Access Denied</h3>
                <p>You need to be logged in to view boards.</p>
                <a href="/login" class="btn-primary">Login</a>
            </div>
        </div>
    </NotAuthorized>
</AuthorizeView>

@code {
    private List<BoardDto> boards = new();
    private List<BoardDto> sortedBoards => boards.OrderBy(b => b.Position).ToList();    
    private CreateBoardRequest newBoard = new();
    private UpdateBoardRequest updateRequest = new();
    private UserDto? currentUser;
    private bool isLoading = true;
    private bool showCreateModal = false;
    private bool showUpdateModal = false;
    private bool isCreating = false;
    private bool isUpdating = false;
    private Guid? updatingBoardId;
    private Dictionary<Guid, bool> boardPermissions = new();
    private Dictionary<Guid, bool> boardOwnership = new();
    private BoardDto? draggedBoard;
    private int? dragOverIndex;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            currentUser = await AuthService.GetCurrentUserAsync();
            if (currentUser != null)
            {
                await LoadBoards();
            }
            else
            {
                Navigation.NavigateTo("/login");
            }
        }
        catch
        {
            Navigation.NavigateTo("/login");
        }
    }

    private async Task LoadBoards()
    {
        isLoading = true;
        try
        {
            boards = await BoardService.GetBoardsAsync();
            boardPermissions = new Dictionary<Guid, bool>();
            boardOwnership = new Dictionary<Guid, bool>();

            var permissionTasks = boards.Select(async board => 
            {
                var canEdit = await BoardService.CanEditAsync(board.Id);
                var isOwner = await BoardService.IsOwnerAsync(board.Id);
                return (board.Id, canEdit, isOwner);
            });

            var results = await Task.WhenAll(permissionTasks);
            foreach (var (id, canEdit, isOwner) in results)
            {
                boardPermissions[id] = canEdit;
                boardOwnership[id] = isOwner;
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Error loading boards: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private void ShowCreateModal()
    {
        newBoard = new CreateBoardRequest();
        showCreateModal = true;
    }

    private void HideCreateModal()
    {
        showCreateModal = false;
        newBoard = new();
    }

    private void ShowUpdateModal(BoardDto board)
    {
        updatingBoardId = board.Id;
        updateRequest = new UpdateBoardRequest { Name = board.Name };
        showUpdateModal = true;
    }

    private void HideUpdateModal()
    {
        showUpdateModal = false;
        updatingBoardId = null;
        updateRequest = new();
    }

    private async Task CreateBoard()
    {
        if (string.IsNullOrWhiteSpace(newBoard.Name) || currentUser == null)
            return;

        isCreating = true;
        try
        {
            var createdBoard = await BoardService.CreateBoardAsync(newBoard);
            createdBoard.Position = 0;

            var positions = sortedBoards
                .Select((b, i) => new BoardPositionDto { Id = b.Id, Position = i + 1 })
                .ToList();
                
            positions.Add(new BoardPositionDto { 
                Id = createdBoard.Id, 
                Position = 0 
            });

            await BoardService.ReorderBoardsAsync(positions);
            
            boards.Add(createdBoard);
            boardPermissions[createdBoard.Id] = true;
            boardOwnership[createdBoard.Id] = true;
            HideCreateModal();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Create error: {ex.Message}");
        }
        finally
        {
            isCreating = false;
        }
    }

    private async Task UpdateBoard()
    {
        if (string.IsNullOrWhiteSpace(updateRequest.Name) || !updatingBoardId.HasValue)
            return;

        isUpdating = true;
        try
        {
            var updatedBoard = await BoardService.UpdateBoardAsync(updatingBoardId.Value, updateRequest);
            
            var index = boards.FindIndex(b => b.Id == updatingBoardId.Value);
            if (index >= 0)
            {
                boards[index] = updatedBoard;
            }
            
            HideUpdateModal();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error updating board: {ex.Message}");
        }
        finally
        {
            isUpdating = false;
        }
    }

    private async Task DeleteBoard(BoardDto board)
    {
        bool confirm = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete '{board.Name}'? This action cannot be undone.");
        if (!confirm) return;

        try
        {
            await BoardService.DeleteBoardAsync(board.Id);
            boards.RemoveAll(b => b.Id == board.Id);
            boardPermissions.Remove(board.Id);
            boardOwnership.Remove(board.Id);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error deleting board: {ex.Message}");
        }
    }

    private async Task LeaveBoard(BoardDto board)
    {
        bool confirm = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to leave '{board.Name}'?");
        if (!confirm) return;

        try
        {
            await BoardService.LeaveBoardAsync(board.Id);
            boards.RemoveAll(b => b.Id == board.Id);
            boardPermissions.Remove(board.Id);
            boardOwnership.Remove(board.Id);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error leaving board: {ex.Message}");
        }
    }

    private void HandleBoardDragStart(DragEventArgs e, BoardDto board)
    {
        draggedBoard = board;
    }

    private void HandleDragOver(DragEventArgs e, int index)
    {
        if (draggedBoard != null)
        {
            dragOverIndex = index;
        }
    }

    private void HandleDragLeave()
    {
        dragOverIndex = null;
    }

    private void HandleBoardDragEnd()
    {
        draggedBoard = null;
        dragOverIndex = null;
    }

    private async Task HandleBoardDrop(DragEventArgs e, int dropIndex)
    {
        if (draggedBoard is null) return;

        try
        {
            var currentIndex = sortedBoards.FindIndex(b => b.Id == draggedBoard.Id);
            if (currentIndex == dropIndex) return;

            // Create new ordered list
            var newOrder = sortedBoards.ToList();
            newOrder.RemoveAt(currentIndex);
            newOrder.Insert(dropIndex, draggedBoard);

            // Generate position updates
            var positions = newOrder
                .Select((b, i) => new BoardPositionDto { Id = b.Id, Position = i })
                .ToList();

            await BoardService.ReorderBoardsAsync(positions);
            
            // Update local positions
            for (int i = 0; i < newOrder.Count; i++)
            {
                newOrder[i].Position = i;
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", $"Reorder error: {ex.Message}");
        }
        finally
        {
            draggedBoard = null;
            dragOverIndex = null;
        }
    }
}