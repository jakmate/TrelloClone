@page "/boards"
@using TrelloClone.Shared.DTOs
@using TrelloClone.Client.Services
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@inject IBoardService BoardService
@inject IAuthService AuthService
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@attribute [Authorize]

<PageTitle>Boards</PageTitle>

<AuthorizeView>
    <Authorized Context="authContext">
        <div class="boards-page">
            <div class="page-header">
                <div class="header-content">
                    <div class="header-text">
                        <h1>My Boards</h1>
                        @if (currentUser != null)
                        {
                            <p class="welcome-text">Welcome back, <strong>@currentUser.UserName</strong>!</p>
                        }
                    </div>
                    <button class="create-btn" @onclick="ShowCreateModal">
                        <i class="bi bi-plus-lg"></i> Create Board
                    </button>
                </div>
            </div>

            @if (isLoading)
            {
                <div class="loading-container">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p>Loading your boards...</p>
                </div>
            }
            else if (boards.Any())
            {
                <div class="boards-grid">
                    @{
                        var sortedBoards = boards.OrderBy(b => b.Position).ToList();
                    }
                    @for (int i = 0; i < sortedBoards.Count; i++)
                    {
                        var board = sortedBoards[i];
                        var index = i;
        
                        <div class="board-drop-zone @(dragOverIndex == index ? "drag-over" : "")" 
                             @ondragover="@((e) => HandleDragOver(e, index))"
                             @ondragover:preventDefault="true"
                             @ondrop="@((e) => HandleBoardDrop(e, index))"
                             @ondragleave="HandleDragLeave">
            
                            <div class="board-item @(draggedBoard?.Id == board.Id ? "dragging" : "")" 
                                 draggable="true" 
                                 @ondragstart="@((e) => HandleBoardDragStart(e, board))"
                                 @ondragend="HandleBoardDragEnd">
                                <BoardCard 
                                    Board="board"
                                    CanEdit="@(boardPermissions.ContainsKey(board.Id) && boardPermissions[board.Id])"
                                    OnUpdate="ShowUpdateModal"
                                    OnDelete="DeleteBoard" />
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="empty-state">
                    <div class="empty-content">
                        <i class="bi bi-kanban"></i>
                        <h3>No boards found</h3>
                        <p>Create your first board to get started!</p>
                        <button class="btn-primary" @onclick="ShowCreateModal">
                            <i class="bi bi-plus-lg"></i> Create Board
                        </button>
                    </div>
                </div>
            }
        </div>

        <!-- Create Board Modal -->
        <div class="modal @(showCreateModal ? "show" : "")" style="display: @(showCreateModal ? "flex" : "none")">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Create New Board</h3>
                    <button class="close-btn" @onclick="HideCreateModal">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <EditForm Model="newBoard" OnValidSubmit="CreateBoard">
                        <DataAnnotationsValidator />
                        <ValidationSummary class="validation-errors" />
                        
                        <div class="form-group">
                            <label for="boardName">Board Name</label>
                            <InputText id="boardName" class="form-control" @bind-Value="newBoard.Name" placeholder="Enter board name" />
                            <ValidationMessage For="@(() => newBoard.Name)" />
                        </div>
                        
                        <div class="modal-footer">
                            <button type="button" class="btn-secondary" @onclick="HideCreateModal">Cancel</button>
                            <button type="submit" class="btn-primary" disabled="@isCreating">
                                @if (isCreating)
                                {
                                    <span class="spinner"></span>
                                }
                                Create Board
                            </button>
                        </div>
                    </EditForm>
                </div>
            </div>
        </div>

        <!-- Update Board Modal -->
        <div class="modal @(showUpdateModal ? "show" : "")" style="display: @(showUpdateModal ? "flex" : "none")">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Update Board</h3>
                    <button class="close-btn" @onclick="HideUpdateModal">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <EditForm Model="updateRequest" OnValidSubmit="UpdateBoard">
                        <DataAnnotationsValidator />
                        <ValidationSummary class="validation-errors" />
                        
                        <div class="form-group">
                            <label for="updateBoardName">Board Name</label>
                            <InputText id="updateBoardName" class="form-control" @bind-Value="updateRequest.Name" />
                            <ValidationMessage For="@(() => updateRequest.Name)" />
                        </div>
                        
                        <div class="modal-footer">
                            <button type="button" class="btn-secondary" @onclick="HideUpdateModal">Cancel</button>
                            <button type="submit" class="btn-primary" disabled="@isUpdating">
                                @if (isUpdating)
                                {
                                    <span class="spinner"></span>
                                }
                                Update Board
                            </button>
                        </div>
                    </EditForm>
                </div>
            </div>
        </div>

        @if (showCreateModal || showUpdateModal)
        {
            <div class="modal-backdrop"></div>
        }
    </Authorized>
    <NotAuthorized>
        <div class="access-denied">
            <div class="denied-content">
                <i class="bi bi-shield-lock"></i>
                <h3>Access Denied</h3>
                <p>You need to be logged in to view boards.</p>
                <a href="/login" class="btn-primary">Login</a>
            </div>
        </div>
    </NotAuthorized>
</AuthorizeView>

@code {
    private List<BoardDto> boards = new();
    private CreateBoardRequest newBoard = new();
    private UpdateBoardRequest updateRequest = new();
    private UserDto? currentUser;
    private bool isLoading = true;
    private bool showCreateModal = false;
    private bool showUpdateModal = false;
    private bool isCreating = false;
    private bool isUpdating = false;
    private Guid? updatingBoardId;
    private Dictionary<Guid, bool> boardPermissions = new();
    private BoardDto? draggedBoard;
    private int? dragOverIndex;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            currentUser = await AuthService.GetCurrentUserAsync();
            if (currentUser != null)
            {
                await LoadBoards();
            }
            else
            {
                Navigation.NavigateTo("/login");
            }
        }
        catch
        {
            Navigation.NavigateTo("/login");
        }
    }

    private async Task LoadBoards()
    {
        isLoading = true;
        try
        {
            boards = await BoardService.GetBoardsAsync();
            boardPermissions = new Dictionary<Guid, bool>();

            var permissionTasks = boards.Select(async board => 
            {
                var canEdit = await BoardService.CanEditAsync(board.Id);
                return (board.Id, canEdit);
            }).ToList();

            foreach (var task in permissionTasks)
            {
                var (boardId, canEdit) = await task;
                boardPermissions[boardId] = canEdit;
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading boards: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private void ShowCreateModal()
    {
        newBoard = new CreateBoardRequest();
        showCreateModal = true;
    }

    private void HideCreateModal()
    {
        showCreateModal = false;
        newBoard = new();
    }

    private void ShowUpdateModal(BoardDto board)
    {
        updatingBoardId = board.Id;
        updateRequest = new UpdateBoardRequest { Name = board.Name };
        showUpdateModal = true;
    }

    private void HideUpdateModal()
    {
        showUpdateModal = false;
        updatingBoardId = null;
        updateRequest = new();
    }

    private async Task CreateBoard()
    {
        if (string.IsNullOrWhiteSpace(newBoard.Name) || currentUser == null)
            return;

        isCreating = true;
        try
        {
            // Create the new board
            var createdBoard = await BoardService.CreateBoardAsync(newBoard);
        
            // Get current boards ordered by position
            var sortedBoards = boards.OrderBy(b => b.Position).ToList();
        
            // Shift existing boards down by 1
            var positions = new List<BoardPositionDto>();
            for (int i = 0; i < sortedBoards.Count; i++)
            {
                sortedBoards[i].Position = i + 1;
                positions.Add(new BoardPositionDto 
                { 
                    Id = sortedBoards[i].Id, 
                    Position = i + 1 
                });
            }

            // Set new board to position 0
            createdBoard.Position = 0;
            positions.Add(new BoardPositionDto
            {
                Id = createdBoard.Id,
                Position = 0
            });

            // Update server with new positions
            await BoardService.ReorderBoardsAsync(positions);

            // Update local state
            boards.Add(createdBoard);
            boardPermissions[createdBoard.Id] = true;
            HideCreateModal();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error creating board: {ex.Message}");
        }
        finally
        {
            isCreating = false;
        }
    }

    private async Task UpdateBoard()
    {
        if (string.IsNullOrWhiteSpace(updateRequest.Name) || !updatingBoardId.HasValue)
            return;

        isUpdating = true;
        try
        {
            var updatedBoard = await BoardService.UpdateBoardAsync(updatingBoardId.Value, updateRequest);
            
            // Update local board list
            var index = boards.FindIndex(b => b.Id == updatingBoardId.Value);
            if (index >= 0)
            {
                boards[index] = updatedBoard;
            }
            
            HideUpdateModal();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error updating board: {ex.Message}");
        }
        finally
        {
            isUpdating = false;
        }
    }

    private async Task DeleteBoard(BoardDto board)
    {
        bool confirm = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete '{board.Name}'?");
        if (!confirm) return;

        try
        {
            await BoardService.DeleteBoardAsync(board.Id);
            boards.RemoveAll(b => b.Id == board.Id);
            boardPermissions.Remove(board.Id);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error deleting board: {ex.Message}");
        }
    }

    private void HandleBoardDragStart(DragEventArgs e, BoardDto board)
    {
        draggedBoard = board;
    }

    private void HandleDragOver(DragEventArgs e, int index)
    {
        if (draggedBoard != null)
        {
            dragOverIndex = index;
        }
    }

    private void HandleDragLeave()
    {
        dragOverIndex = null;
    }

    private void HandleBoardDragEnd()
    {
        draggedBoard = null;
        dragOverIndex = null;
    }

    private async Task HandleBoardDrop(DragEventArgs e, int dropIndex)
    {
        if (draggedBoard == null) return;

        try
        {
            var sortedBoards = boards.OrderBy(b => b.Position).ToList();
            var draggedIndex = sortedBoards.FindIndex(b => b.Id == draggedBoard.Id);
        
            if (draggedIndex == dropIndex) return; // No change

            // Remove dragged board from current position
            sortedBoards.RemoveAt(draggedIndex);
        
            // Insert at new position
            sortedBoards.Insert(dropIndex, draggedBoard);
        
            // Update positions
            var positions = new List<BoardPositionDto>();
            for (int i = 0; i < sortedBoards.Count; i++)
            {
                sortedBoards[i].Position = i;
                positions.Add(new BoardPositionDto 
                { 
                    Id = sortedBoards[i].Id, 
                    Position = i 
                });
            }
        
            // Update server
            await BoardService.ReorderBoardsAsync(positions);
        
            // Update local state
            boards = sortedBoards;
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error reordering boards: {ex.Message}");
        }
        finally
        {
            draggedBoard = null;
            dragOverIndex = null;
        }
    }
}